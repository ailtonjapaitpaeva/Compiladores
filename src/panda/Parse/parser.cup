// panda.cup    -*- mode: Java -*-

package panda.Parse;

import panda.Absyn.*;
import javaslang.collection.List;
import panda.ErrorMsg.Loc;
import panda.ErrorMsg.ErrorMsg;
import panda.Symbol.Symbol;

import java_cup.runtime.SymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;




// Routines and variables for use by the code embedded in the grammar
action code
{:
  //static Loc loc() 

  //{
  //  return new Loc();
  //}

  Loc loc(Location left, Location right) {
    return parser.loc(left, right);
  }
:};

// Methods and variables to be placed directly within the generated parser class
parser code
{:
  ErrorMsg errorMsg;
  
  public PandaCup(PandaLex lex, SymbolFactory symbolFactory, ErrorMsg errorMsg) {
    this(lex, symbolFactory);
    this.errorMsg = errorMsg;
  }


  Loc loc(Location left, Location right) {
    return new Loc(left, right);
  }
 
  public void report_error(String message, Object info) {
    Loc loc;
    if (info instanceof ComplexSymbol) {
      ComplexSymbol tok = (ComplexSymbol) info;
      loc = loc(tok.xleft, tok.xright);
      message += ": " + Tokens.dumpToken(tok);
    }
    else
      loc = new Loc();
    errorMsg.error(loc, message);
  }

  public void syntax_error(java_cup.runtime.Symbol tok) {
    report_error("syntax error", tok);
  }
:}

terminal Long    	LITINT;
terminal Boolean 	LITBOOL;
terminal Symbol 	ID;
terminal         	IF, THEN, ELSE;
terminal Double 	LITREAL;
terminal Character 	LITCHAR;
terminal 			WHILE, DO;
terminal 			PLUS, MINUS, TIMES;
terminal        	LPAREN, RPAREN, COMMA;
terminal        	LBRACE, RBRACE, SEMI;
terminal			VAR, ASSIGN, COLON;
terminal			LET, IN;
terminal 			BREAK, EQ;


non terminal Exp 		program;
non terminal Exp 		exp;
non terminal Var 		var;
non terminal Dec  		dec;
non terminal List<Dec> decs;

start with program;

program ::=
  exp:x                             {: RESULT = x; :}
  
  ;

var ::= 
	ID:v 							{: RESULT = new SimpleVar(loc(vxleft,vxright),v); :}

;

exp ::=
  LITREAL:x                         {: RESULT = new RealExp(loc(xxleft,xxright),x); :}
| LITINT:x                          {: RESULT = new IntExp(loc(xxleft,xxright),x); :}
| LITBOOL:x                         {: RESULT = new BoolExp(loc(xxleft,xxright),x); :}
| IF:i exp:t THEN exp:a ELSE exp:b  {: RESULT = new IfExp(loc(ixleft,bxright),t,a,b); :}
| IF:i exp:t THEN exp:a             {: RESULT = new IfExp(loc(ixleft,axright),t,a,null); :}
| LITCHAR:x                         {: RESULT = new CharExp(loc(xxleft,xxright),x); :}
| WHILE exp:test DO exp:result		{: RESULT = new WhileExp(loc(testxleft,resultxright),test,result); :}
| LET:l decs:d IN exp:x				{: RESULT = new LetExp(loc(lxleft,xxright),d,x); :}
| var: v							{: RESULT = new VarExp(loc(vxleft,vxright),v); :}

;

dec ::=
	VAR:v ID:n COLON ID:t EQ exp:e 	{: RESULT = new VarDec(loc(vxleft,exright), n, t ,e); :}
|	VAR:v ID:n  EQ exp:e 			{: RESULT = new VarDec(loc(vxleft,exright), n, null ,e); :}
;

decs::=
	dec:d							{: RESULT = List.of(d); :}
|	dec:d decs:ds 					{: RESULT = ds.prepend(d); :}
;