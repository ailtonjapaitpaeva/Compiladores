// panda.cup    -*- mode: Java -*-

package panda.Parse;

import panda.Absyn.*;
import javaslang.collection.List;
import panda.ErrorMsg.Loc;
import panda.ErrorMsg.ErrorMsg;
import panda.Symbol.Symbol;

import java_cup.runtime.SymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;




// Routines and variables for use by the code embedded in the grammar
action code
{:
  //static Loc loc() 

  //{
  //  return new Loc();
  //}

  Loc loc(Location left, Location right) {
    return parser.loc(left, right);
  }
:};

// Methods and variables to be placed directly within the generated parser class
parser code
{:
  ErrorMsg errorMsg;
  
  public PandaCup(PandaLex lex, SymbolFactory symbolFactory, ErrorMsg errorMsg) {
    this(lex, symbolFactory);
    this.errorMsg = errorMsg;
  }


  Loc loc(Location left, Location right) {
    return new Loc(left, right);
  }
 
  public void report_error(String message, Object info) {
    Loc loc;
    if (info instanceof ComplexSymbol) {
      ComplexSymbol tok = (ComplexSymbol) info;
      loc = loc(tok.xleft, tok.xright);
      message += ": " + Tokens.dumpToken(tok);
    }
    else
      loc = new Loc();
    errorMsg.error(loc, message);
  }

  public void syntax_error(java_cup.runtime.Symbol tok) {
    report_error("syntax error", tok);
  }
:}

terminal Long    	LITINT;
terminal Boolean 	LITBOOL;
terminal         	IF, THEN, ELSE;
terminal Double 	LITREAL;
terminal Character 	LITCHAR;
terminal 			WHILE, DO;
terminal 			PLUS, MINUS, TIMES;
terminal        	LPAREN, RPAREN, COMMA;
terminal        	LBRACE, RBRACE, SEMI;
terminal			VAR, ASSIGN, COLON;
terminal			LET, IN;
terminal 			BREAK;

non terminal Exp program;
non terminal Exp exp;

start with program;

program ::=
  exp:x                             {: RESULT = x; :}
  ;

exp ::=
  LITREAL:x                         {: RESULT = new RealExp(loc(xxleft,xxright),x); :}
| LITINT:x                          {: RESULT = new IntExp(loc(xxleft,xxright),x); :}
| LITBOOL:x                         {: RESULT = new BoolExp(loc(xxleft,xxright),x); :}
| IF:i exp:t THEN exp:a ELSE exp:b  {: RESULT = new IfExp(loc(ixleft,bxright),t,a,b); :}
| IF:i exp:t THEN exp:a             {: RESULT = new IfExp(loc(ixleft,axright),t,a,null); :}
| LITCHAR:x                         {: RESULT = new CharExp(loc(xxleft,xxright),x); :}
| WHILE exp:test DO exp:result		{: RESULT = new WhileExp(loc(testxleft,resultxright),test,result); :}
;

